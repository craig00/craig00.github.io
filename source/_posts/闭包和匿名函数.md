---
title: 闭包和匿名函数
date: 2017-04-26 23:16:58
categories: javascript
tags: [javascript]
---

匿名函数和闭包在js中是不一样的，匿名函数一般是没有名字的函数，而闭包是指有权访问另一个函数作用域中的变量的函数。

``` javascript
var counting=(function(){   
    var count=0;   
	function autoPlus(){   
        console.log(count++);   
    }   
	return autoPlus;   
})();   
``` 

上述代码是一个典型的闭包，但是js中作用域链是这样的：内层函数中的变量没有声明，那么它就会沿着作用域链一级一级向上搜索变量名，直至全局变量window对象定义的变量，所以这里autoPlus函数能够访问外层函数的count变量并不是因为闭包。

而闭包的特点在于它引用了外部函数的变量，则外部函数的变量就不会被销毁，直到闭包被销毁。一般匿名函数执行后，其内包含的变量和作用域链都是会被销毁的，但是如上述代码，count就没有被销毁。

this 对象是在运行时基于函数的执行环境绑定的：在全局函数中， this 等于 window，而当函数被作为某个对象的方法调用时， this 等于那个对象。不过，匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。

``` javascript
var name = "The Window";
var object = {
	name : "My Object",
	getNameFunc : function () {
		return function () {
			return this.name;
		};
	}
};
``` 
``` javascript
alert(object.getNameFunc()()); //"The Window"（在非严格模式下）
var name = "The Window";
var object = {
	name : "My Object",
	getName: function () {
		return this.name;
	}
};
object.getName(); //"My Object"
(object.getName)(); //"My Object"
(object.getName = object.getName)(); //"The Window"，在非严格模式下
//第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以 this 的值不能得到维持，结果就返回了"The Window"。
``` 
``` javascript
var a = {
  print: function(){
    console.log(this);
  }
}
a.print() // this is a because a is to the left of the dot
var b = a.print;
b() // this is window, because there is nothing to the left of the dot
``` 

匿名函数中的this为什么会指向全局对象呢？其实就是嵌套太多（匿名函数中return匿名函数），或者类似于上面的例子（把匿名函数通过赋值的方式赋给了全局对象），所以到最后把匿名函数的执行环境给了全局对象。

而箭头函数的this总是指向词法作用域，也就是外层调用者obj，不会有上述问题。

